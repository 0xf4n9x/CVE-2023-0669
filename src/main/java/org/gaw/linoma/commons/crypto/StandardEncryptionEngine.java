package org.gaw.linoma.commons.crypto;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;


public class StandardEncryptionEngine implements EncryptionEngine {
    private Cipher encryptionCipher;
    private Cipher decryptionCipher;
    private byte[] keyBytes;

    public StandardEncryptionEngine(byte[] key, byte[] iv, String keyAlgorithm, String cipherAlgorithm) throws CryptoException {
        this.encryptionCipher = null;
        this.decryptionCipher = null;
        this.keyBytes = null;
        try {
            SecretKeySpec keySpec = new SecretKeySpec(key, keyAlgorithm);
            this.encryptionCipher = Cipher.getInstance(cipherAlgorithm);
            this.encryptionCipher.init(1, keySpec, new IvParameterSpec(iv));
            this.decryptionCipher = Cipher.getInstance(cipherAlgorithm);
            this.decryptionCipher.init(2, keySpec, new IvParameterSpec(iv));
            this.keyBytes = key;
        } catch (Throwable t) {
            throw new CryptoException("Error initializing symmetric key", t);
        }
    }

    public StandardEncryptionEngine(Cipher encryptionCipher, Cipher decryptionCipher) {
        this.encryptionCipher = null;
        this.decryptionCipher = null;
        this.keyBytes = null;
        this.encryptionCipher = encryptionCipher;
        this.decryptionCipher = decryptionCipher;
    }

    public byte[] encrypt(byte[] bytes) throws CryptoException {
        byte[] doFinal;
        synchronized (this.encryptionCipher) {
            try {
                doFinal = this.encryptionCipher.doFinal(bytes);
            } catch (IllegalBlockSizeException e) {
                throw new RuntimeException(e);
            } catch (BadPaddingException e) {
                throw new RuntimeException(e);
            }
        }
        return doFinal;
    }

    public byte[] decrypt(byte[] encryptedValue) throws CryptoException {
        byte[] doFinal;
        synchronized (this.decryptionCipher) {
            try {
                doFinal = this.decryptionCipher.doFinal(encryptedValue);
            } catch (IllegalBlockSizeException e) {
                throw new RuntimeException(e);
            } catch (BadPaddingException e) {
                throw new RuntimeException(e);
            }
        }
        return doFinal;
    }

    public byte[] getKeyBytes() {
        return this.keyBytes;
    }

    public void init() {
    }

}